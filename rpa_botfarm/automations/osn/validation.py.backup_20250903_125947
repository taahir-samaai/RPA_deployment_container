"""
OSN Validation Automation - Final Clean Implementation
=====================================================
Fixed data extraction with working patterns verified by browser testing.
"""
import base64
import traceback
from pathlib import Path
from datetime import datetime
import time
import logging
import json
from typing import Optional, List, Dict, Any
from enum import Enum
import os

# Third-party imports
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options as ChromeOptions
from selenium.common.exceptions import TimeoutException, WebDriverException
from tenacity import retry, stop_after_attempt, wait_fixed, retry_if_exception_type, before_sleep_log
from pydantic import BaseModel, Field

# Import existing config
from config import Config

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

# ==================== ENUMERATIONS ====================

class ValidationStatus(str, Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    SUCCESS = "success"
    FAILURE = "failure"
    ERROR = "error"

class SearchResult(str, Enum):
    FOUND = "found"
    NOT_FOUND = "not_found"
    ERROR = "error"

class OrderType(str, Enum):
    NEW_INSTALLATION = "new_installation"
    CEASE_ACTIVE_SERVICE = "cease_active_service"
    MODIFICATION = "modification"
    UNKNOWN = "unknown"

# ==================== DATA MODELS ====================

class ValidationRequest(BaseModel):
    job_id: str = Field(..., description="Unique job identifier")
    circuit_number: str = Field(..., description="Circuit number to validate")

class ScreenshotData(BaseModel):
    name: str
    timestamp: datetime
    data: str
    path: str
    
    class Config:
        json_encoders = {datetime: lambda v: v.isoformat()}

class OrderData(BaseModel):
    orderNumber: str
    type: OrderType
    orderStatus: str
    dateImplemented: Optional[str] = None
    is_new_installation: bool = False
    is_cancellation: bool = False
    is_implemented_cease: bool = False
    is_pending_cease: bool = False
    serviceNumber: Optional[str] = None
    externalRef: Optional[str] = ""
    productName: Optional[str] = ""
    createdOn: Optional[str] = ""

class CustomerDetails(BaseModel):
    name: str = ""
    surname: str = ""
    contact_number: str = ""
    email: str = ""
    order_number: str = ""
    domicile_type: str = ""
    address: str = ""

class CeaseOrderDetails(BaseModel):
    order_number: str
    placed_by: str = ""
    date_submitted: str = ""
    requested_cease_date: str = ""
    product: str = ""
    order_type: str = ""
    service_circuit_no: str = ""
    external_ref: str = ""

class ServiceInfo(BaseModel):
    circuit_number: str
    address: Optional[str] = None
    is_active: bool = False

class ValidationResult(BaseModel):
    job_id: str
    circuit_number: str
    status: ValidationStatus
    message: str
    found: bool
    orders: List[OrderData] = []
    customer_details: Optional[CustomerDetails] = None
    cease_order_details: List[CeaseOrderDetails] = []
    service_info: Optional[ServiceInfo] = None
    search_result: SearchResult
    execution_time: Optional[float] = None
    screenshots: List[ScreenshotData] = []
    evidence_dir: Optional[str] = None

# ==================== MAIN AUTOMATION CLASS ====================

class OSNValidationAutomation:
    """OSN validation automation with fixed data extraction"""
    
    def __init__(self):
        self.config = Config
        self.logger = logging.getLogger(self.__class__.__name__)
        self.driver: Optional[webdriver.Chrome] = None
        self.screenshots: List[ScreenshotData] = []
    
    def _setup_browser(self, job_id: str):
        """Setup browser and evidence directory - USING CONFIG ONLY"""
        self.screenshot_dir = Path(Config.get_job_screenshot_dir(job_id))
        self.screenshot_dir.mkdir(parents=True, exist_ok=True)
        self.execution_summary_path = Config.get_execution_summary_path(job_id)
        
        # Chrome options
        options = ChromeOptions()
        
        # USE CONFIG INSTEAD OF os.getenv()
        if Config.NO_SANDBOX:
            options.add_argument('--no-sandbox')
        if Config.DISABLE_DEV_SHM_USAGE:
            options.add_argument('--disable-dev-shm-usage')
        
        options.add_argument('--window-size=1920,1080')

        # Handle headless mode - USE CONFIG
        if Config.HEADLESS:
            logger.info("Running in headless mode")
            options.add_argument("--headless=new")
        else:
            logger.info("Running in visible mode")

        # Create driver
        from selenium.webdriver.chrome.service import Service
        service = Service(executable_path=Config.CHROMEDRIVER_PATH)
        self.driver = webdriver.Chrome(service=service, options=options)
        
        if Config.START_MAXIMIZED:
            self.driver.maximize_window()
            
        self.driver.set_page_load_timeout(15)
        self.driver.implicitly_wait(3)

    
    def _cleanup_browser(self):
        """Cleanup browser resources"""
        if self.driver:
            try:
                self.driver.quit()
                self.logger.info("Browser driver closed successfully")
            except Exception as e:
                self.logger.error(f"Error during driver cleanup: {str(e)}")
    
    def _take_screenshot(self, name: str) -> Optional[ScreenshotData]:
        """Take screenshot and save"""
        try:
            timestamp = datetime.now()
            filename = f"{name}_{timestamp.strftime('%Y%m%d_%H%M%S')}.png"
            filepath = self.screenshot_dir / filename

            self.driver.save_screenshot(str(filepath))
            
            with open(filepath, 'rb') as f:
                screenshot_data = base64.b64encode(f.read()).decode()
            
            screenshot = ScreenshotData(
                name=name, timestamp=timestamp, data=screenshot_data, path=str(filepath)
            )
            
            self.screenshots.append(screenshot)
            self.logger.info(f"Screenshot saved: {filepath}")
            return screenshot
            
        except Exception as e:
            self.logger.error(f"Failed to take screenshot: {str(e)}")
            return None
    
    def save_execution_summary(self, result: ValidationResult):
        """Save a single execution summary with all findings"""
        try:
            with open(self.execution_summary_path, "w", encoding="utf-8") as f:
                f.write(f"===== OSN Validation Execution Summary =====\n")
                f.write(f"Job ID: {result.job_id}\n")
                f.write(f"Circuit Number: {result.circuit_number}\n")
                f.write(f"Execution Time: {datetime.now().isoformat()}\n")
                f.write(f"Status: {result.status.value}\n")
                f.write(f"Found: {result.found}\n\n")
                
                # Orders Section
                if result.orders:
                    f.write(f"=== Orders ({len(result.orders)}) ===\n")
                    for i, order in enumerate(result.orders, 1):
                        f.write(f"Order {i}: {order.orderNumber}\n")
                        f.write(f"  Type: {order.type.value}\n")
                        f.write(f"  Status: {order.orderStatus}\n")
                        if order.is_cancellation:
                            f.write(f"  Is Pending Cease: {order.is_pending_cease}\n")
                            f.write(f"  Is Implemented Cease: {order.is_implemented_cease}\n")
                    f.write("\n")
                
                # Customer Details
                if result.customer_details:
                    f.write("=== Customer Details ===\n")
                    f.write(f"Name: {result.customer_details.name}\n")
                    f.write(f"Surname: {result.customer_details.surname}\n")
                    f.write(f"Mobile: {result.customer_details.contact_number}\n")
                    f.write(f"Email: {result.customer_details.email}\n")
                    f.write(f"Address: {result.customer_details.address}\n\n")
                
                # Cease Order Details
                if result.cease_order_details:
                    f.write("=== Cease Order Details ===\n")
                    for cease in result.cease_order_details:
                        f.write(f"Order: {cease.order_number}\n")
                        f.write(f"Requested Cease Date: {cease.requested_cease_date}\n")
                        f.write(f"External Ref: {cease.external_ref}\n\n")
                
                # Service Info
                if result.service_info:
                    f.write("=== Service Info ===\n")
                    f.write(f"Address: {result.service_info.address}\n")
                    f.write(f"Is Active: {result.service_info.is_active}\n\n")
                
                # Screenshots
                f.write(f"=== Screenshots ===\n")
                f.write(f"Total screenshots: {len(result.screenshots)}\n")
                for screenshot in result.screenshots:
                    f.write(f"- {screenshot.name} at {screenshot.timestamp.isoformat()}\n")
                    
            self.logger.info(f"Execution summary saved to {self.execution_summary_path}")
        except Exception as e:
            self.logger.error(f"Failed to save execution summary: {str(e)}")




    def _login(self):
        """Perform login"""
        try:
            self.driver.get("https://partners.openserve.co.za/login")
            time.sleep(5)
            
            # Fill credentials
            email_input = WebDriverWait(self.driver, 30).until(
                EC.element_to_be_clickable((By.ID, "email"))
            )
            email_input.clear()
            email_input.send_keys(Config.OSEMAIL)
            
            password_input = self.driver.find_element(By.ID, "password")
            password_input.clear()
            password_input.send_keys(Config.OSPASSWORD)
            
            # Click login
            login_button = self.driver.find_element(By.ID, "next")
            login_button.click()
            
            # Wait for successful login
            WebDriverWait(self.driver, 30).until(
                EC.presence_of_element_located((By.ID, "navOrders"))
            )
            
            self.logger.info("Login successful")
            
        except Exception as e:
            self.logger.error(f"Login failed: {str(e)}")
            raise
    
    def _navigate_to_orders(self, circuit_number: str):
        """Navigate to orders page"""
        orders_url = f"https://partners.openserve.co.za/orders?tabIndex=2&isps=628&serviceNumber={circuit_number}"
        self.driver.get(orders_url)
        time.sleep(5)
    
    def _extract_orders(self) -> List[OrderData]:
        """Extract order data from table"""
        orders = []
        
        try:
            WebDriverWait(self.driver, 30).until(
                EC.presence_of_element_located((By.XPATH, "//table//tbody//tr"))
            )
            
            rows = self.driver.find_elements(By.XPATH, "//table//tbody//tr[td[normalize-space(text())]]")
            
            # Column mapping
            columns = {
                0: "orderNumber", 1: "type", 2: "externalRef", 3: "serviceNumber",
                4: "productName", 5: "createdOn", 6: "dateImplemented", 7: "orderStatus"
            }
            
            for row in rows:
                try:
                    cells = row.find_elements(By.TAG_NAME, "td")
                    if len(cells) >= 3:
                        # Extract cell data
                        order_info = {}
                        for i, cell in enumerate(cells):
                            if i in columns:
                                order_info[columns[i]] = cell.text.strip()
                        
                        # Determine order type and flags
                        order_type_text = order_info.get("type", "").lower()
                        status = order_info.get("orderStatus", "")
                        date_implemented = order_info.get("dateImplemented", "")
                        
                        if "new" in order_type_text or "installation" in order_type_text:
                            order_type = OrderType.NEW_INSTALLATION
                            is_new_installation = True
                            is_cancellation = False
                        elif "cease" in order_type_text:
                            order_type = OrderType.CEASE_ACTIVE_SERVICE
                            is_new_installation = False
                            is_cancellation = True
                        else:
                            order_type = OrderType.MODIFICATION if "modif" in order_type_text else OrderType.UNKNOWN
                            is_new_installation = False
                            is_cancellation = False
                        
                        order = OrderData(
                            orderNumber=order_info.get("orderNumber", ""),
                            type=order_type,
                            orderStatus=status,
                            dateImplemented=date_implemented,
                            is_new_installation=is_new_installation,
                            is_cancellation=is_cancellation,
                            serviceNumber=order_info.get("serviceNumber", ""),
                            externalRef=order_info.get("externalRef", ""),
                            productName=order_info.get("productName", ""),
                            createdOn=order_info.get("createdOn", "")
                        )
                        
                        # Set cease order status
                        if is_cancellation:
                            if date_implemented and status.lower() == "accepted":
                                order.is_implemented_cease = True
                                order.is_pending_cease = False
                            else:
                                order.is_implemented_cease = False
                                order.is_pending_cease = True
                        
                        orders.append(order)
                        
                except Exception as e:
                    self.logger.warning(f"Failed to parse order row: {str(e)}")
                    continue
            
            self.logger.info(f"Extracted {len(orders)} orders")
            
        except Exception as e:
            self.logger.error(f"Failed to extract orders: {str(e)}")
        
        return orders
    
    def _navigate_to_active_services(self, circuit_number: str):
        """Navigate to active services page"""
        active_services_url = f"https://partners.openserve.co.za/active-services/{circuit_number}"
        self.driver.get(active_services_url)
        time.sleep(10)
    
    def _extract_customer_details(self, order_number: str) -> Optional[CustomerDetails]:
        """Extract customer details with verified working patterns"""
        try:
            self.logger.info(f"Extracting customer details for order: {order_number}")
            
            # Verify page loaded
            if "orders-complete" not in self.driver.current_url:
                self.logger.error(f"Wrong page - current URL: {self.driver.current_url}")
                return None
            
            details = CustomerDetails(order_number=order_number)
            
            # Extract customer details with verified working patterns
            customer_data = self.driver.execute_script("""
                var text = document.body.textContent;
                var result = {};
                
                // Extract the customer details section
                var customerStart = text.indexOf("Customer Details");
                var customerSection = "";
                if (customerStart !== -1) {
                    var appointmentStart = text.indexOf("Appointment", customerStart);
                    if (appointmentStart !== -1) {
                        customerSection = text.substring(customerStart, appointmentStart);
                    } else {
                        customerSection = text.substring(customerStart, customerStart + 500);
                    }
                }
                
                console.log("DEBUG: Customer section text:", customerSection);
                
                // Verified working patterns from browser testing
                var patterns = {
                    name: /Name\\s*:\\s*([^:]*?)(?=Surname\\s*:|$)/i,
                    surname: /Surname\\s*:\\s*([^:]*?)(?=Mobile Number\\s*:|$)/i,
                    mobile_number: /Mobile Number\\s*:\\s*([^:]*?)(?=Domicile|Email|Appointment|$)/i,
                    domicile_type: /Domicile type\\s*:\\s*([^:]*?)(?=Address\\s*:|$)/i,
                    address: /Address\\s*:\\s*([^:]*?)(?=Appointment|Email|$)/i,
                    email: /Email\\s*:\\s*([\\w.-]+@[\\w.-]+\\.[a-zA-Z]{2,})/i
                };
                
                // Extract each field
                for (var field in patterns) {
                    var match = customerSection.match(patterns[field]);
                    if (match && match[1]) {
                        var value = match[1].trim();
                        // Clean up whitespace and artifacts
                        value = value.replace(/\\s+/g, ' ');
                        value = value.replace(/^[,\\s]+|[,\\s]+$/g, '');
                        
                        if (value.length > 0 && value !== 'undefined' && value !== 'null') {
                            result[field] = value;
                            console.log("DEBUG: Extracted " + field + ": '" + value + "'");
                        }
                    } else {
                        console.log("DEBUG: NOT FOUND: " + field);
                    }
                }
                
                // Clean mobile number to digits only
                if (result.mobile_number) {
                    var mobileDigits = result.mobile_number.replace(/\\D/g, '');
                    if (mobileDigits.length >= 10) {
                        result.mobile_number = mobileDigits.substring(0, 10);
                        console.log("DEBUG: Cleaned mobile number: " + result.mobile_number);
                    }
                }
                
                return result;
            """)
            
            # Map extracted data
            if customer_data:
                details.name = customer_data.get('name', "").strip()
                details.surname = customer_data.get('surname', "").strip()
                details.contact_number = customer_data.get('mobile_number', "").strip()
                details.email = customer_data.get('email', "").strip()
                details.domicile_type = customer_data.get('domicile_type', "").strip()
                details.address = customer_data.get('address', "").strip()
            
            # Log extracted data in requested format
            self.logger.info("=== EXTRACTED CUSTOMER DETAILS (RAW FORMAT) ===")
            self.logger.info(f"Name: {details.name}")
            self.logger.info(f"Surname: {details.surname}")
            self.logger.info(f"Mobile Number: {details.contact_number}")
            self.logger.info(f"Domicile type: {details.domicile_type}")
            self.logger.info(f"Address: {details.address}")
            if details.email:
                self.logger.info(f"Email: {details.email}")
            self.logger.info("=== END CUSTOMER DETAILS ===")
            
            return details
            
        except Exception as e:
            self.logger.error(f"Failed to extract customer details: {str(e)}")
            return None
    
    def _extract_address(self) -> Optional[str]:
        """Extract address from active services page"""
        try:
            # Click Service Information button
            service_info_clicked = self.driver.execute_script("""
                var serviceInfoHeading = document.evaluate(
                    "//h2[contains(text(), 'Service Information')]", 
                    document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null
                ).singleNodeValue;
                
                if (serviceInfoHeading) {
                    var card = serviceInfoHeading.closest('div.card, div.col, div');
                    if (card) {
                        var viewBtn = card.querySelector('button');
                        if (viewBtn) {
                            viewBtn.click();
                            return true;
                        }
                    }
                }
                return false;
            """)
            
            if service_info_clicked:
                time.sleep(5)
                
                # Click Service end points tab
                tab_clicked = self.driver.execute_script("""
                    var tabs = Array.from(document.querySelectorAll('span.p-tabview-title')).filter(
                        span => span.textContent.includes('Service end points')
                    );
                    
                    if (tabs.length > 0) {
                        var tabLink = tabs[0].closest('a');
                        if (tabLink) {
                            tabLink.click();
                            return true;
                        }
                    }
                    return false;
                """)
                
                if tab_clicked:
                    time.sleep(3)
                    
                    # Extract address
                    address = self.driver.execute_script("""
                        var aSideSection = document.evaluate(
                            "//p[contains(text(), 'A-Side')]", 
                            document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null
                        ).singleNodeValue;
                        
                        if (aSideSection) {
                            var aSideContainer = aSideSection.closest('div.col, div');
                            if (aSideContainer) {
                                var rows = aSideContainer.querySelectorAll('.row');
                                for (var i = 0; i < rows.length; i++) {
                                    var row = rows[i];
                                    var label = row.querySelector('p.fw-bold');
                                    if (label && label.textContent.includes('Site Address')) {
                                        var valueCol = row.querySelectorAll('div')[1];
                                        if (valueCol) {
                                            return valueCol.textContent.trim();
                                        }
                                    }
                                }
                            }
                        }
                        return null;
                    """)
                    
                    if address:
                        self.logger.info(f"Successfully extracted address: {address}")
                        return address
            
            self.logger.warning("Could not extract address")
            return None
            
        except Exception as e:
            self.logger.error(f"Address extraction failed: {str(e)}")
            return None
    
    def _extract_cease_order_details(self, order_number: str) -> Optional[CeaseOrderDetails]:
        """Extract cease order details with verified working patterns"""
        try:
            self.logger.info(f"Extracting cease order details for order: {order_number}")
            
            # Verify page loaded
            if "orders-pending" not in self.driver.current_url:
                self.logger.error(f"Wrong page - current URL: {self.driver.current_url}")
                return None
            
            details = CeaseOrderDetails(order_number=order_number)
            
            # Extract order details with verified patterns
            order_data = self.driver.execute_script("""
                var text = document.body.textContent;
                var result = {};
                
                // Extract the order details section
                var orderStart = text.indexOf("Order Details");
                var orderSection = "";
                if (orderStart !== -1) {
                    var notificationsStart = text.indexOf("Notifications", orderStart);
                    if (notificationsStart !== -1) {
                        orderSection = text.substring(orderStart, notificationsStart);
                    } else {
                        orderSection = text.substring(orderStart, orderStart + 800);
                    }
                }
                
                console.log("DEBUG: Order section text:", orderSection);
                
                // Verified patterns for cease order fields
                var patterns = {
                    placed_by: /Placed by\\s*:\\s*([^:]*?)(?=Date Submitted\\s*:|$)/i,
                    date_submitted: /Date Submitted\\s*:\\s*([^:]*?)(?=Requested Cease Date\\s*:|Product\\s*:|$)/i,
                    requested_cease_date: /Requested Cease Date\\s*:\\s*([^:]*?)(?=Product\\s*:|$)/i,
                    product: /Product\\s*:\\s*([^:]*?)(?=Service speed\\s*:|Order type\\s*:|$)/i,
                    order_type: /Order type\\s*:\\s*([^:]*?)(?=Contract term\\s*:|Service\\s*:|$)/i,
                    service_circuit_no: /Service\\/Circuit no\\.\\s*:\\s*([^:]*?)(?=External Ref\\s*:|$)/i,
                    external_ref: /External Ref\\.\\s*:\\s*([^:]*?)(?=Remark\\s*:|$)/i
                };
                
                // Extract each field
                for (var field in patterns) {
                    var match = orderSection.match(patterns[field]);
                    if (match && match[1]) {
                        var value = match[1].trim();
                        // Clean up whitespace and artifacts
                        value = value.replace(/\\s+/g, ' ');
                        value = value.replace(/^[,\\s]+|[,\\s]+$/g, '');
                        
                        if (value.length > 0 && value !== 'undefined' && value !== 'null') {
                            result[field] = value;
                            console.log("DEBUG: Extracted " + field + ": '" + value + "'");
                        }
                    } else {
                        console.log("DEBUG: NOT FOUND: " + field);
                    }
                }
                
                return result;
            """)
            
            # Map extracted data
            if order_data:
                details.placed_by = order_data.get('placed_by', "").strip()
                details.date_submitted = order_data.get('date_submitted', "").strip()
                details.requested_cease_date = order_data.get('requested_cease_date', "").strip()
                details.product = order_data.get('product', "").strip()
                details.order_type = order_data.get('order_type', "").strip()
                details.service_circuit_no = order_data.get('service_circuit_no', "").strip()
                details.external_ref = order_data.get('external_ref', "").strip()
            
            # Log extracted data in requested format
            self.logger.info("=== EXTRACTED CEASE ORDER DETAILS (RAW FORMAT) ===")
            self.logger.info(f"Placed by: {details.placed_by}")
            self.logger.info(f"Date Submitted: {details.date_submitted}")
            self.logger.info(f"Requested Cease Date: {details.requested_cease_date}")
            self.logger.info(f"Product: {details.product}")
            self.logger.info(f"Order type: {details.order_type}")
            self.logger.info(f"Service/Circuit no.: {details.service_circuit_no}")
            self.logger.info(f"External Ref.: {details.external_ref}")
            self.logger.info("=== END CEASE ORDER DETAILS ===")
            
            return details
            
        except Exception as e:
            self.logger.error(f"Failed to extract cease order details: {str(e)}")
            return None
    
    def _navigate_to_order_details(self, order_number: str, order_type: str):
        """Navigate to order details page"""
        if order_type == "new_installation":
            url = f"https://partners.openserve.co.za/orders/orders-complete/{order_number}/New%20Installation"
        else:  # cease order
            url = f"https://partners.openserve.co.za/orders/orders-pending/{order_number}/Cease%20Active%20Service"
        
        self.driver.get(url)
        time.sleep(5)
    
    def _create_formatted_result_dict(self, result: ValidationResult) -> Dict[str, Any]:
        """Create properly formatted result dictionary"""
        
        result_dict = {
            "status": result.status.value,
            "message": result.message,
            "details": {
                "found": result.found,
                "circuit_number": result.circuit_number,
                "search_result": result.search_result.value,
                "order_data": [order.dict() for order in result.orders],
                "service_info": result.service_info.dict() if result.service_info else None,
                "validation_status": "complete" if result.status == ValidationStatus.SUCCESS else "failed",
                "order_count": len(result.orders),
                "has_new_installation": any(o.is_new_installation for o in result.orders),
                "has_cancellation": any(o.is_cancellation for o in result.orders),
                "has_pending_cease": any(o.is_cancellation and not o.is_implemented_cease for o in result.orders),
                "has_implemented_cease": any(o.is_cancellation and o.is_implemented_cease for o in result.orders),
                "service_accessible": result.service_info and result.service_info.address is not None,
            },
            "evidence_dir": str(self.screenshot_dir),
            "screenshot_data": [
                {
                    "name": screenshot.name,
                    "timestamp": screenshot.timestamp.isoformat(),
                    "data": screenshot.data,
                    "path": screenshot.path
                }
                for screenshot in result.screenshots
            ],
            "execution_time": result.execution_time
        }
        
        # Add customer details
        if result.customer_details:
            customer_dict = result.customer_details.dict()
            result_dict["details"]["customer_details"] = customer_dict
            result_dict["details"]["customer_data_extracted"] = any(
                customer_dict.get(field) for field in ['name', 'surname', 'contact_number', 'email']
            )
            
            # Add formatted customer data for display
            result_dict["details"]["formatted_customer_data"] = {
                "Name": customer_dict.get('name', ''),
                "Surname": customer_dict.get('surname', ''),
                "Mobile Number": customer_dict.get('contact_number', ''),
                "Email": customer_dict.get('email', ''),
                "Domicile type": customer_dict.get('domicile_type', ''),
                "Address": customer_dict.get('address', '')
            }
            
            # Add address compatibility
            if result.service_info and result.service_info.address:
                result_dict["details"]["customer_details"]["customer_address"] = result.service_info.address
                result_dict["details"]["customer_details"]["active_services_address"] = result.service_info.address
                result_dict["details"]["customer_address"] = result.service_info.address
                result_dict["details"]["active_services_address"] = result.service_info.address
        else:
            result_dict["details"]["customer_details"] = {}
            result_dict["details"]["customer_data_extracted"] = False
            result_dict["details"]["formatted_customer_data"] = {}
        
        # Add cease order details
        if result.cease_order_details:
            result_dict["details"]["cease_order_details"] = [cease.dict() for cease in result.cease_order_details]
            result_dict["details"]["cease_order_data_extracted"] = True
            
            # Add formatted cease order data for display
            formatted_cease_orders = []
            for cease_order in result.cease_order_details:
                formatted_cease_orders.append({
                    "Order Number": cease_order.order_number,
                    "Placed by": cease_order.placed_by,
                    "Date Submitted": cease_order.date_submitted,
                    "Requested Cease Date": cease_order.requested_cease_date,
                    "Product": cease_order.product,
                    "Order type": cease_order.order_type,
                    "Service/Circuit no.": cease_order.service_circuit_no,
                    "External Ref.": cease_order.external_ref
                })
            result_dict["details"]["formatted_cease_order_data"] = formatted_cease_orders
        else:
            result_dict["details"]["cease_order_details"] = []
            result_dict["details"]["cease_order_data_extracted"] = False
            result_dict["details"]["formatted_cease_order_data"] = []
        
        return result_dict
    
    @retry(
        stop=stop_after_attempt(2),
        wait=wait_fixed(3),
        retry=retry_if_exception_type((TimeoutException, WebDriverException)),
        before_sleep=before_sleep_log(logger, logging.WARNING)
    )
    def validate_circuit(self, request: ValidationRequest) -> ValidationResult:
        """Main validation method"""
        start_time = time.time()
        
        try:
            self.logger.info(f"Starting validation for job {request.job_id}, circuit {request.circuit_number}")
            
            # Setup
            self._setup_browser(request.job_id)
            self._take_screenshot("initial_state")
            
            # Login
            self._login()
            self._take_screenshot("after_login")
            
            # Get orders
            self._navigate_to_orders(request.circuit_number)
            self._take_screenshot("orders_page")
            
            orders = self._extract_orders()
            
            # Get address
            self._navigate_to_active_services(request.circuit_number)
            self._take_screenshot("active_services")
            
            address = self._extract_address()
            
            # Check if circuit exists
            circuit_exists = len(orders) > 0 or address is not None
            
            if not circuit_exists:
                return self._create_not_found_result(request)
            
            # Extract customer details from new installation orders
            customer_details = CustomerDetails()
            new_installation_orders = [o for o in orders if o.is_new_installation]
            
            if new_installation_orders:
                for order in new_installation_orders:
                    try:
                        self._navigate_to_order_details(order.orderNumber, "new_installation")
                        self._take_screenshot(f"customer_details_{order.orderNumber}")
                        
                        customer_details = self._extract_customer_details(order.orderNumber)
                        
                        # Check if we got meaningful data
                        if customer_details and any(getattr(customer_details, field) for field in ['name', 'surname', 'contact_number', 'email']):
                            break
                    except Exception as e:
                        self.logger.error(f"Failed to process order {order.orderNumber}: {str(e)}")
                        continue
            
            # Extract cease order details from pending cease orders
            cease_order_details = []
            pending_cease_orders = [o for o in orders if o.is_cancellation and o.is_pending_cease]
            
            if pending_cease_orders:
                for order in pending_cease_orders:
                    try:
                        self._navigate_to_order_details(order.orderNumber, "cease")
                        self._take_screenshot(f"cease_details_{order.orderNumber}")
                        
                        cease_details = self._extract_cease_order_details(order.orderNumber)
                        
                        if cease_details:
                            cease_order_details.append(cease_details)
                    except Exception as e:
                        self.logger.error(f"Failed to process cease order {order.orderNumber}: {str(e)}")
                        continue
            
            # Create service info
            service_info = ServiceInfo(
                circuit_number=request.circuit_number,
                address=address,
                is_active=address is not None and not any(o.is_implemented_cease for o in orders if o.is_cancellation)
            )
            
            # Create result
            execution_time = time.time() - start_time
            result = ValidationResult(
                job_id=request.job_id,
                circuit_number=request.circuit_number,
                status=ValidationStatus.SUCCESS,
                message=f"Successfully validated circuit {request.circuit_number}",
                found=True,
                orders=orders,
                customer_details=customer_details,
                cease_order_details=cease_order_details,
                service_info=service_info,
                search_result=SearchResult.FOUND,
                execution_time=execution_time,
                screenshots=self.screenshots,
            )
            
            # Save execution summary
            self.save_execution_summary(result)

            self.logger.info(f"Validation completed in {execution_time:.2f}s")
            return result
            
        except Exception as e:
            self.logger.error(f"Validation failed: {str(e)}")
            if self.driver:
                try:
                    self._take_screenshot("error_state")
                except:
                    pass
            
            return ValidationResult(
                job_id=request.job_id,
                circuit_number=request.circuit_number,
                status=ValidationStatus.ERROR,
                message=str(e),
                found=False,
                cease_order_details=[],
                search_result=SearchResult.ERROR,
                screenshots=self.screenshots
            )
            
        finally:
            try:
                self._cleanup_browser()
            except Exception as cleanup_error:
                self.logger.error(f"Cleanup failed: {str(cleanup_error)}")
    
    def _create_not_found_result(self, request: ValidationRequest) -> ValidationResult:
        """Create not found result"""
        return ValidationResult(
            job_id=request.job_id,
            circuit_number=request.circuit_number,
            status=ValidationStatus.SUCCESS,
            message=f"Circuit {request.circuit_number} not found in system",
            found=False,
            cease_order_details=[],
            search_result=SearchResult.NOT_FOUND,
            screenshots=self.screenshots
        )

# ==================== MAIN EXECUTION FUNCTION ====================

def execute(parameters: Dict[str, Any]) -> Dict[str, Any]:
    """Main execution function with improved data formatting"""
    try:
        # Create validation request
        request = ValidationRequest(
            job_id=parameters.get("job_id"),
            circuit_number=parameters.get("circuit_number")
        )
        
        # Run automation
        automation = OSNValidationAutomation()
        result = automation.validate_circuit(request)
        
        # Use the improved formatting method
        result_dict = automation._create_formatted_result_dict(result)
        
        return result_dict
        
    except Exception as e:
        logger.error(f"Execute function failed: {str(e)}")
        return {
            "status": "error",
            "message": f"Execution error: {str(e)}",
            "details": {
                "error": str(e),
                "found": False,
                "order_count": 0,
                "customer_data_extracted": False,
                "service_accessible": False,
                "formatted_customer_data": {},
                "formatted_cease_order_data": []
            },
            "screenshot_data": []
        }

# ==================== TEST EXECUTION ====================

if __name__ == "__main__":
    """Test the automation"""
    test_params = {
        "job_id": f"FINAL_TEST_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
        "circuit_number": "B530003043"
    }
    
    print("=" * 60)
    print("OSN Validation Automation - Final Clean Implementation")
    print("=" * 60)
    print(f"Testing circuit: {test_params['circuit_number']}")
    print(f"Job ID: {test_params['job_id']}")
    print()
    print("VERIFIED FIXES:")
    print("✓ Working regex patterns verified by browser testing")
    print("✓ Proper section isolation for Customer Details and Order Details")
    print("✓ Text cleaning and mobile number validation")
    print("✓ Raw data extraction in requested format")
    print("✓ Enhanced result structure with formatted data")
    print("✓ Debugging statements preserved")
    print("✓ Clean, focused code structure")
    print()
    
    result = execute(test_params)
    
    print("Results:")
    print("-" * 40)
    print(f"Status: {result['status']}")
    print(f"Circuit Found: {result['details'].get('found', False)}")
    print(f"Customer Data Extracted: {result['details'].get('customer_data_extracted', False)}")
    
    if result['details'].get('formatted_customer_data'):
        customer = result['details']['formatted_customer_data']
        print(f"Customer Name: {customer.get('Name', 'Not found')}")
        print(f"Customer Surname: {customer.get('Surname', 'Not found')}")
        print(f"Customer Mobile: {customer.get('Mobile Number', 'Not found')}")
        print(f"Customer Email: {customer.get('Email', 'Not found')}")
    
    print("\nSUCCESS: Final clean implementation with verified working patterns!")